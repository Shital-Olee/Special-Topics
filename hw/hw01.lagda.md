COMP360C: Computer-checked Programs and Proofs
Spring 2026
Homework 01


# Updates/hints

* The proposition T was not declared in the module hw01 line; add it
  like below or just use P or Q in place of T when you're defining the
  types in those problems.

* The proposition MissScarletGuilty means Miss Scarlet *is* guilty
  (there was a typo in the explanation).

* If you have a function whose domain is of type Either A B and you want
  Agda to put in the cases, first put in a variable for the input to the
  function (called, say, x), then type x in the goal on the right-hand
  side, and then do C-c C-c.  You need to tell Agda which variable to
  case on, because in general there might be many possible things you
  could case.

* If you have a function that outputs a pair type A × B, and you want to
  return a pair of two things, you can put the text ? , ? in the goal on
  the right-hand side and then refine.  Agda will generate two goals for
  the two parts of the pair, so you can work on each of them separately.
  In general, you can put a ? at any point when you want to refine with
  a partial solution.

* If you have a function that takes a pair as input, you can either use
  first/second or pattern-match to get at the pieces.  See the exchange
  and exchange-again examples in the Lecture 2 notes.

* In the Clue problem, if you want to case-analyze the output of a
  helper function, the easiest way to do this is with a local helper
  function in a 'where' like in the parity example in Lecture 4.  You
  could also just make a top-level function, but then you will need to
  pass it any of the original function's inputs that it uses.  The
  advantage of the local function is that all of the original function's
  inputs are already available in the helper function's body.

```
module hw01 (P Q R S T : Set) where

  -- this defines the × type and the Unit type

  record _×_ (A : Set) (B : Set) : Set where
    constructor _,_
    field
      first : A
      second : B
  open _×_ public

  record Unit : Set where
    constructor <>

  data Either (A : Set) (B : Set) : Set where
    Inl : A → Either A B -- pronounced "in left"
    Inr : B → Either A B -- pronounced "in right"

  data Void : Set where

```

# Propositions as types exercies

For each of the following propositions, translate the proposition to a
type. Prove the proposition by giving a program of that type.

```
  -- (R ∨ (S ∧ T)) ⊃ (R ∨ S) ∧ (R ∨ T)
  distrib∨∧ : (Either R (S × T)) → (Either R S) × (Either R T)
  distrib∨∧ (Inl x) = Inl x , Inl x
  distrib∨∧ (Inr x) = Inr (first x), Inr (second x)

  -- ( (R ∨ S) ∧ (R ∨ T) ) ⊃ (R ∨ (S ∧ T)) 
  undistrib∨∧ : ((Either R S) × (Either R T)) → (Either R (S × T))
  undistrib∨∧ (Inl x , Inl x₁) = Inl x
  undistrib∨∧ (Inl x , Inr x₁) = Inl x
  undistrib∨∧ (Inr x , Inl x₁) = Inl x₁
  undistrib∨∧ (Inr x , Inr x₁) = Inr (x , x₁)


  -- ((R ∧ S) ∨ (R ∧ T)) ⊃ (R ∧ (S ∨ T)) 
  undistrib∧∨ : (Either (R × S) (R × T)) → (R × (Either S T)) 
  undistrib∧∨ (Inl (x , y)) = x , Inl y
  undistrib∧∨ (Inr (x , t)) = x , Inr t

  -- ((P ∧ Q) ∧ R) ⊃ (P ∧ (Q ∧ R))
  ∧assoc1 : ((P × Q) × R) → (P × (Q × R))
  ∧assoc1 ((x , y) , z) = (x , (y , z))

  -- (P ∧ (Q ∧ R)) ⊃ ((P ∧ Q) ∧ R) 
  ∧assoc2 : (P × (Q × R)) → ((P × Q) × R)
  ∧assoc2 (x , (y , z)) = (x , y) , z

  -- ((P ∨ Q) ∨ R) ⊃ (P ∨ (Q ∨ R))
  ∨assoc1 : (Either (Either P Q) R) → (Either P (Either Q R))
  ∨assoc1 (Inl (Inl x)) = Inl x
  ∨assoc1 (Inl (Inr x)) = Inr (Inl x)
  ∨assoc1 (Inr y) = Inr (Inr y)

  -- (P ∨ (Q ∨ R)) ⊃ ((P ∨ Q) ∨ R)
  ∨assoc2 : (Either P (Either Q R)) → Either (Either P Q) R
  ∨assoc2 (Inr (Inl x)) = Inl (Inr x)
  ∨assoc2 (Inr (Inr x)) = Inr x
  ∨assoc2 (Inl y) = Inl (Inl y)


  -- (R ⊃ S) ⊃ (S ⊃ T) ⊃ (R ⊃ T)
  ⊃transitive : (R → S) → (S → T) → (R → T) 
  ⊃transitive (x y z) = y(x(z))

  -- ((P ⊃ Q) ∧ (P ⊃ R)) ⊃ (P ⊃ (Q ∧ R)) 
  distrib⊃∧1 : ((P → Q) × (P → R)) → (P → (Q × R))
  distrib⊃∧1 = {!!} 

  -- ((P ⊃ R) ∧ (Q ⊃ R)) ⊃ ((P ∨ Q) ⊃ R) 
  distrib⊃∨2 : ((P → R) × (Q → R)) → ((Either P Q) → R)
  distrib⊃∨2 = {!!}

  -- ((P ⊃ Q) ∨ (P ⊃ R)) ⊃ (P ⊃ (Q ∨ R)) 
  distrib⊃∨-right : (Either (P → Q) (P → R)) → (P → (Either Q R))
  distrib⊃∨-right = {!!}
```

# Clue

The following puzzle is derived from the game Clue. A player has various pieces of
information regarding the perpetrator, the weapon, and the location of a murder:

If Mr. Green is guilty, then it was with the candle-stick in the
billiard room or with the revolver in the hall. If it was in the hall,
then Miss Scarlet did it. Either it was done with the revolver, or in
the hall.

From these facts, a player must make inferences about who committed the
crime, such as:

Therefore Mr. Green didn’t do it.

Formalize this situation and show that MrGeen is not guilty.

We will define logical negation (not) as folows
```
  -- type \neg to enter this symbol
  ¬ : Set → Set
  ¬ A = (A → Void)
```

This says that (not A) is true when A implied the false proposition Void.  

```
  module Clue (MrGreenGuilty MissScarletGuilty Revolver CandleStick BillardRoom Hall : Set) where

    -- The proposition MrGreenGuilty means Mr Green is guilty
    -- The proposition MissScarletGuilty means Miss Scarlet is guilty
    -- The proposition Revolver means the murder weapon was the revolver
    -- The proposition CandleStick means the murder weapon was the candlestick
    -- The proposition BillardRoom means the murder took place in the billard room
    -- The proposition Hall means the murder took place in the hall

    -- Translate the problem to a type
    clue : -- If Mr. Green is guilty, then it was with the candle-stick in the billiard room or with the revolver in the hall. 
            (MrGreenGuilty → Either (CandleStick × BillardRoom) (Revolver × Hall))
         -- If it was in the hall, then Miss Scarlet is guilty. 
         -> (Hall → MissScarletGuilty)
         -- Either it was done with the revolver, or in the hall.
         -> (Either Revolver Hall)
         -- There was only one murder weapon (i.e. it is not the case that both Revolver and CandleStick are true)
         -> (¬(Revolver × CandleStick))
         -- There was only one murderer (i.e. it is not the case that both MrGreenGuilty and MissScarletGuilty are true)
         -> (¬(MrGreenGuilty × MissScarletGuilty))
         -- MrGreen is not guilty
         -> (¬ MrGreenGuilty)
    clue part1 part2 (Inl part3) part4 part5 part6 = freeMrGreen(part1(part6))
      where
        freeMrGreen : (Either (CandleStick × BillardRoom)) (Revolver × Hall) → Void
        freeMrGreen (Inl x) = part4(part3 , first(x))
        freeMrGreen (Inr x) = part5 (part6 , part2(second(x)))
    clue part1 part2 (Inr part3) part4 part5 part6 = part5(part6 , part2(part3))
```
